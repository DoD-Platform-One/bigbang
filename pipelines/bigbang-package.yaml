# global rules for when pipelines run
workflow:
  rules:
    # skip pipeline for MRs with docs label
    - if: $CI_MERGE_REQUEST_LABELS =~ /(^|,)kind::docs(,|$)/
      when: never
    # run pipeline for manual tag events
    - if: $CI_COMMIT_TAG
    # run pipeline on merge request events
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    # run pipeline on commits to default branch
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# Include templates and cluster creation jobs
include:
  - local: '/library/templates.yaml'

stages:
  - ‚öôÔ∏è configuration validation
  - ü§û package tests
  - üì¶ package
  - üöÄ release

variables:
  PIPELINE_REPO: https://repo1.dso.mil/platform-one/big-bang/pipeline-templates/pipeline-templates.git
  PIPELINE_REPO_DESTINATION: "../pipeline-repo"
  PIPELINE_REPO_BRANCH: master
  IMAGE_LIST: images.txt
  IMAGE_PKG: images.tar.gz
  REPOS_PKG: repositories.tar.gz
  RELEASE_NAME: ${CI_PROJECT_NAME}
  RELEASE_BUCKET: umbrella-bigbang-releases
  PACKAGE_NAMESPACE: ${CI_PROJECT_NAME}
  PACKAGE_HELM_NAME: ${CI_PROJECT_NAME}
  REGISTRY1_USER: $REGISTRY1_USER
  PIPELINE_TYPE: "PKG"
  DEBUG_ENABLED: "false"

configuration validation:
  stage: ‚öôÔ∏è configuration validation
  extends:
    - .bigbang-gitlab-runner-tags
    - .util-image
    - .templates
  variables:
    GENERIC_POLICY_PATH: "${PIPELINE_REPO_DESTINATION}/policies"
  script:
    # Print Package Directory Structure
    - package_structure
    # Global policy tests
    - global_policy_tests
    # Package specific tests
    - package_policy_tests
    # Package API Deprecation Check
    - package_deprecation_check
  allow_failure:
    exit_codes:
      - 2
      - 3
  retry:
    max: 2
    when:
      - unknown_failure
      - stuck_or_timeout_failure
      - runner_system_failure

chart update check:
  stage: ‚öôÔ∏è configuration validation
  extends:
    - .bigbang-gitlab-runner-tags
    - .util-image
    - .templates
  rules:
    # skip job when MR title contains 'SKIP UPDATE CHECK'
    - if: '$CI_MERGE_REQUEST_TITLE =~ /SKIP UPDATE CHECK/'
      when: never
    # run pipeline on merge request events
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
  script:
    # Check for chart.yaml version bump and changelog additions
    - chart_update_check
    - changelog_format_check
  retry:
    max: 2
    when:
      - unknown_failure
      - stuck_or_timeout_failure
      - runner_system_failure

clean install:
  stage: ü§û package tests
  extends:
    - .k3d-ci-pkg
  script:
    # Install and wait for dependencies
    - dependency_install
    - dependency_wait
    # Pull initial list of image dependencies that we will want to remove from the final images.txt
    - dependency_images
    # Install and wait for package
    - package_install
    - package_wait
    # Once package installed, pull another list of images. List will include dependencies and package images.
    - installed_images
    ## Create final images.txt: Remove items from the dependencies list from the full-list.
    # Remove rancher upstream images. The k3d cluster will inject images for various purposes like load balancers, PVCs, etc. 
    # If we don't explicitly filter those out there's the potential that they sneak in
    - package_images
    # Install and wait for pos-install packages
    - post_install_packages
    - post_install_wait
    # Run package helm tests
    - package_test
    # Run tests for API deprecations in cluster
    - cluster_deprecation_check
    - touch $CI_PROJECT_DIR/success
  artifacts:
    when: always
    paths:
      - events.txt
      - images.txt
      - tests/cypress/screenshots
      - tests/cypress/videos
      - cypress-artifacts
    expire_in: 3 days
  allow_failure:
    exit_codes: 200
  retry:
    max: 2
    when:
      - unknown_failure
      - stuck_or_timeout_failure
      - runner_system_failure

upgrade:
  stage: ü§û package tests
  extends:
    - .k3d-ci-pkg
  rules:
    # skip job when MR title contains 'SKIP UPGRADE'
    - if: '$CI_MERGE_REQUEST_TITLE =~ /SKIP UPGRADE/'
      when: never
    # skip pipeline for branches that start with "docs"
    - if: '$CI_COMMIT_REF_NAME =~ /^doc*/i'
      when: never
    # run pipeline on merge request events
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
  script:
    - echo "Installing ${CI_PROJECT_NAME} from ${CI_MERGE_REQUEST_TARGET_BRANCH_NAME}"
    - echo -e "\e[0Ksection_start:`date +%s`:package_checkout1[collapsed=true]\r\e[0KPackage Checkout"
    # Get MR target branch
    - git fetch && git checkout ${CI_MERGE_REQUEST_TARGET_BRANCH_NAME}
    - echo -e "\e[0Ksection_end:`date +%s`:package_checkout1\r\e[0K"
    # Install and wait for dependencies
    - dependency_install
    - dependency_wait
    # Install and wait for package
    - package_install
    - package_wait
    # Install and wait for pos-install packages
    - post_install_packages
    - post_install_wait
    # Run package helm tests
    - package_test
    - echo "Upgrading ${CI_PROJECT_NAME} to ${CI_MERGE_REQUEST_SOURCE_BRANCH_NAME}"
    - echo -e "\e[0Ksection_start:`date +%s`:package_checkout2[collapsed=true]\r\e[0KPackage Upgrade Checkout"
    # Get MR source branch
    - git reset --hard && git clean -fd
    - git checkout ${CI_MERGE_REQUEST_SOURCE_BRANCH_NAME}
    - echo -e "\e[0Ksection_end:`date +%s`:package_checkout2\r\e[0K"
    # Upgrade and wait for dependencies
    - dependency_install
    - dependency_wait
    # Upgrade and wait for Package
    - package_install
    - package_wait
    # Install and wait for pos-install packages
    - post_install_packages
    - post_install_wait
    # Re-run package helm tests
    - package_upgrade_test
    - cluster_deprecation_check
    - touch $CI_PROJECT_DIR/success
  artifacts:
    when: always
    paths:
      - events.txt
      - images.txt
      - tests/cypress/screenshots
      - tests/cypress/videos
      - cypress-artifacts
    expire_in: 3 days
  allow_failure:
    exit_codes: 
      - 123
      - 200
  retry:
    max: 2
    when:
      - unknown_failure
      - stuck_or_timeout_failure
      - runner_system_failure

package:
  stage: üì¶ package
  extends:
    - .bigbang-gitlab-runner-tags
    - .util-image
    - .templates
  rules:
    # run job for manual tag events or test-ci::release MRs, check for AWS access
    - if: '($CI_COMMIT_TAG && $AWS_ACCESS_KEY_ID) || ($CI_MERGE_REQUEST_LABELS =~ /(^|,)test-ci::release(,|$)/ && $TEST_AWS_ACCESS_KEY_ID)'
  script:
    # Populate images list in synker config
    # Tar up synker as well
    - package_synker
    # Package repos
    - package_repos
    # Prep release
    - package_prep
    # Publish packages to s3 release
    - package_publish
    # Get release notes from CHANGELOG
    - package_release_notes
  artifacts:
    paths:
      - release_notes.txt
    expire_in: 3 days
  retry:
    max: 2
    when:
      - unknown_failure
      - stuck_or_timeout_failure
      - runner_system_failure

release:
  stage: üöÄ release
  extends:
    - .bigbang-gitlab-runner-tags
    - .util-image
    - .templates
  rules:
    # run job for manual tag events or test-ci::release MRs, check for AWS access
    - if: '($CI_COMMIT_TAG && $AWS_ACCESS_KEY_ID) || ($CI_MERGE_REQUEST_LABELS =~ /(^|,)test-ci::release(,|$)/ && $TEST_AWS_ACCESS_KEY_ID)'
  variables:
    RELEASE_ENDPOINT: https://${RELEASE_BUCKET}.s3-${AWS_DEFAULT_REGION}.amazonaws.com/packages/${CI_PROJECT_NAME}/${CI_COMMIT_TAG}
  script:
    # Use release-cli to cut a release in Gitlab or simulate a dry-run & print asset links
    - package_release
  retry:
    max: 2
    when:
      - unknown_failure
      - stuck_or_timeout_failure
      - runner_system_failure
