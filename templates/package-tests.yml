# global rules for when pipelines run
workflow:
  rules:
    # run pipeline for manual tag events
    - if: $CI_COMMIT_TAG
    # run pipeline on merge request events
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    # run pipeline on commits to default branch
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    # skip pipeline for branches that start with "docs"
    - if: '$CI_COMMIT_REF_NAME =~ /^doc*/i'
      when: never

stages:
  - configuration validation
  - package tests
  - package
  - release

variables:
  PIPELINE_REPO: https://repo1.dso.mil/platform-one/big-bang/pipeline-templates/pipeline-templates.git
  PIPELINE_REPO_DESTINATION: "../pipeline-repo"
  IMAGE_LIST: images.txt
  IMAGE_PKG: images.tar.gz
  REPOS_PKG: repositories.tar.gz
  RELEASE_NAME: ${CI_PROJECT_NAME}
  RELEASE_BUCKET: umbrella-bigbang-releases
  PACKAGE_NAMESPACE: ${CI_PROJECT_NAME}
  PACKAGE_HELM_NAME: ${CI_PROJECT_NAME}
  CI_REG1_USER: ${REGISTRY1_USER}

.bigbang-dogfood:
  tags:
    - bigbang
    - dogfood
    - generic

.k3d-ci:
  image: registry.dso.mil/platform-one/big-bang/pipeline-templates/pipeline-templates/k3d-builder:0.0.5
  tags:
    - bigbang
    - privileged
    - dogfood
    - packages
  variables:
    DOCKER_HOST: tcp://localhost:2376
    DOCKER_TLS_CERTDIR: "/certs"
    DOCKER_TLS_VERIFY: 1
    DOCKER_CERT_PATH: "$DOCKER_TLS_CERTDIR/client"
    DOCKER_DRIVER: overlay2


configuration validation:
  image: registry.dso.mil/platform-one/big-bang/pipeline-templates/pipeline-templates/k3d-builder:0.0.5
  stage: configuration validation
  extends:
    - .bigbang-dogfood
  variables:
    GENERIC_POLICY_PATH: "${PIPELINE_REPO_DESTINATION}/policies"

  before_script:
    - |
      if [ -z ${PIPELINE_REPO_BRANCH} ]; then
        PIPELINE_REPO_BRANCH="$(yq e '.include[0].ref' ./.gitlab-ci.yml)"
        if [ -z ${PIPELINE_REPO_BRANCH} ]; then
          PIPELINE_REPO_BRANCH="master"
        fi
      fi
    - git clone -b ${PIPELINE_REPO_BRANCH} ${PIPELINE_REPO} ${PIPELINE_REPO_DESTINATION}
  script:
    # Place configuration validation tests here
    - echo "Directory structure of repository:"
    - tree .
    - echo "Generic configuration validation tests:"

    # Global policy tests
    - |
      if [ $(ls -1 tests/test-values.y*ml 2>/dev/null | wc -l) -gt 0 ]; then
        echo "Checking test values..."
        helm conftest chart --policy ${GENERIC_POLICY_PATH} -f tests/test-values.y*ml
        echo "Checking chart values..."
        helm conftest chart --policy ${GENERIC_POLICY_PATH}
      else
        helm conftest chart --policy ${GENERIC_POLICY_PATH}
      fi

    # Package specific tests
    - |
      if [ -d "tests/policy" ]; then
        echo "App specific configuration validation tests:"
        if [ $(ls -1 tests/test-values.y*ml 2>/dev/null | wc -l) -gt 0 ]; then
          echo "Checking test values..."
          helm conftest chart --policy tests/policy -f tests/test-values.y*ml
          echo "Checking chart values..."
          helm conftest chart --policy tests/policy
        else
          helm conftest chart --policy tests/policy
        fi
      fi

package tests:
  stage: package tests
  extends:
    - .k3d-ci

  variables:
    WAIT_PATH: "${PIPELINE_REPO_DESTINATION}/jobs/wait/wait.sh"
    K3D_CONFIG_PATH: "${PIPELINE_REPO_DESTINATION}/jobs/k3d-ci/config.yaml"

  before_script:
    # Clone pipeline repo for waits & k3d config
    - |
      if [ -z ${PIPELINE_REPO_BRANCH} ]; then
        PIPELINE_REPO_BRANCH="$(yq e '.include[0].ref' ./.gitlab-ci.yml)"
        if [ -z ${PIPELINE_REPO_BRANCH} ]; then
          PIPELINE_REPO_BRANCH="master"
        fi
      fi
    - git clone -b ${PIPELINE_REPO_BRANCH} ${PIPELINE_REPO} ${PIPELINE_REPO_DESTINATION}
    - source ${WAIT_PATH}

    # Create docker network and cluster
    - docker network create ${CI_JOB_ID} --driver=bridge -o "com.docker.network.driver.mtu"="1450"
    - k3d cluster create ${CI_JOB_ID} --config ${K3D_CONFIG_PATH} --network ${CI_JOB_ID}
    - until kubectl get deployment coredns -n kube-system -o go-template='{{.status.availableReplicas}}' | grep -v -e '<no value>'; do sleep 1s; done

    # Setup pull secrets for project
    - |
      if [ ! -z ${PROJECT_NAME} ]; then
        if [ ${PACKAGE_NAMESPACE} == ${CI_PROJECT_NAME} ]; then
          PACKAGE_NAMESPACE=${PROJECT_NAME}
        fi
      fi
      kubectl create namespace ${PACKAGE_NAMESPACE}
      kubectl create -n ${PACKAGE_NAMESPACE} secret docker-registry private-registry --docker-server="https://registry1.dso.mil" --docker-username="${CI_REG1_USER}" --docker-password="${REGISTRY1_PASSWORD}"
      kubectl create -n ${PACKAGE_NAMESPACE} secret docker-registry private-registry-mil --docker-server="https://registry1.dso.mil" --docker-username="${CI_REG1_USER}" --docker-password="${REGISTRY1_PASSWORD}"

    # Check for istio in project name and install it if needed
    - |
      if [[ "${CI_PROJECT_NAME}" != *"istio"* ]]; then
        istioctl install -y
      fi

    # Generate throwaway cert for *.bigbang.dev, NOTE: special case for istio-operator - no cert needed
    - |
      if [[ "${PACKAGE_NAMESPACE}" != "istio-operator" ]]; then
        openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout tls.key -out tls.crt -subj "/CN=*.bigbang.dev"
        kubectl create -n istio-system secret tls wildcard-cert --key="tls.key" --cert="tls.crt"
      fi
    # Apply gateway if it exists (don't always create since istio creates its own)
    - |
      if [ -f "tests/main-test-gateway.yaml" ]; then
        kubectl apply -f tests/main-test-gateway.yaml
      fi

    # Check for dependency repos, set up pull secrets, and helm install with test-values if present default if not
    - |
      if [ -f "tests/dependencies.yaml" ]; then
        yq e ".*.git | path | .[-2]" "tests/dependencies.yaml" | while IFS= read -r i; do
          dep_name=$i

          dep_repo=$(yq e ".${i}.git.repo" "tests/dependencies.yaml")
          if [[ -z ${dep_repo} || ${dep_repo} == "null" ]]; then
            dep_repo=$(yq e ".${i}.git" "tests/dependencies.yaml")
            if [[ -z ${dep_repo} || ${dep_repo} == "null" ]]; then
              continue
            fi
          fi

          dep_branch=$(yq e ".${i}.git.tag" "tests/dependencies.yaml")
          if [[ -z ${dep_branch} || ${dep_branch} == "null" ]]; then
            dep_branch=$(yq e ".${i}.branch" "tests/dependencies.yaml")
          fi

          dep_namespace=$(yq e ".${i}.namespace" "tests/dependencies.yaml")
          if [[ -z ${dep_namespace} || ${dep_namespace} == "null" ]]; then
            dep_namespace=$dep_name
          fi

          dep_helm_name=$(yq e ".${i}.package-name" "tests/dependencies.yaml")
          if [[ -z ${dep_helm_name} || ${dep_helm_name} == "null" ]]; then
            dep_helm_name=$dep_name
          fi

          if [[ -z ${dep_branch} || ${dep_branch} == "null" ]]; then
            echo "Cloning default branch from ${dep_repo}"
            git clone ${dep_repo} repos/${dep_name}
          else
            echo "Cloning tag ${dep_branch} from ${dep_repo}"
            git clone -b ${dep_branch} ${dep_repo} repos/${dep_name}
          fi

          echo "Installing dependency: repos/${dep_name} into ${dep_namespace} namespace"
          if ! kubectl get namespace ${dep_namespace} 2> /dev/null; then
            kubectl create namespace ${dep_namespace};
          fi
          if ! kubectl get secret -n ${dep_namespace} private-registry 2> /dev/null; then
            kubectl create -n ${dep_namespace} secret docker-registry private-registry --docker-server="https://registry1.dso.mil" --docker-username="${CI_REG1_USER}" --docker-password="${REGISTRY1_PASSWORD}"
          fi
          if ! kubectl get secret -n ${dep_namespace} private-registry-mil 2> /dev/null; then
            kubectl create -n ${dep_namespace} secret docker-registry private-registry-mil --docker-server="https://registry1.dso.mil" --docker-username="${CI_REG1_USER}" --docker-password="${REGISTRY1_PASSWORD}"
          fi

          if [ $(ls -1 repos/${dep_name}/tests/test-values.y*ml 2>/dev/null | wc -l) -gt 0 ]; then
            echo "Helm installing repos/${dep_name}/chart into ${dep_namespace} namespace using repos/${dep_name}/tests/test-values.yaml for values"
            helm install --wait --timeout 600s ${dep_helm_name} repos/${dep_name}/chart -n ${dep_namespace} -f repos/${dep_name}/tests/test-values.y*ml
          else
            echo "Helm installing repos/${dep_name}/chart into ${dep_namespace} namespace using default values"
            helm install --wait --timeout 600s ${dep_helm_name} repos/${dep_name}/chart -n ${dep_namespace}
          fi
        done
      fi

    - sleep 10
    - kubectl wait --for=condition=established --timeout 60s -A crd --all > /dev/null
    - |
      if [ -f tests/dependencies.yaml ]; then
        yq e ".*.git | path | .[-2]" "tests/dependencies.yaml" | while IFS= read -r i; do
          dep_name=$i
          if [ -f repos/${dep_name}/tests/wait.sh ]; then
            source repos/${dep_name}/tests/wait.sh
            echo "Waiting on dependency resources..."
            wait_project
          fi
        done
      fi
    - wait_sts
    - wait_daemonset
    - kubectl wait --for=condition=available --timeout 600s -A deployment --all > /dev/null
    - kubectl wait --for=condition=ready --timeout 600s -A pods --all --field-selector status.phase=Running > /dev/null

  script:
    # Place kubernetes package test here
    - echo "Package install"

    # Override the PACKAGE_HELM_NAME with PROJECT_NAME (backwards compatibility)
    - |
      if [ ! -z ${PROJECT_NAME} ]; then
        if [ ${PACKAGE_HELM_NAME} == ${CI_PROJECT_NAME} ]; then
          PACKAGE_HELM_NAME=${PROJECT_NAME}
        fi
      fi

    # Check for test values file
    - |
      if [ $(ls -1 tests/test-values.y*ml 2>/dev/null | wc -l) -gt 0 ]; then
        echo "Helm installing ${CI_PROJECT_NAME}/chart into ${PACKAGE_NAMESPACE} namespace using ${CI_PROJECT_NAME}/tests/test-values.yaml for values"
        helm install --wait --timeout 600s ${PACKAGE_HELM_NAME} chart -n ${PACKAGE_NAMESPACE} -f tests/test-values.y*ml
      else
        echo "Helm installing ${CI_PROJECT_NAME}/chart into ${PACKAGE_NAMESPACE} namespace using default values"
        helm install --wait --timeout 600s ${PACKAGE_HELM_NAME} chart -n ${PACKAGE_NAMESPACE}
      fi

    # Wait for resources to be created and come alive
    - sleep 10
    - kubectl wait --for=condition=established --timeout 60s -A crd --all > /dev/null
    - |
      if [ -f tests/wait.sh ]; then
        source tests/wait.sh
        echo "Waiting on project resources..."
        wait_project
      fi
    - wait_sts
    - wait_daemonset
    - kubectl wait --for=condition=available --timeout 600s -A deployment --all > /dev/null
    - kubectl wait --for=condition=ready --timeout 600s -A pods --all --field-selector status.phase=Running > /dev/null

    - echo "Package tests"
    # If istio-ingressgateway has a loadBalancer IP and ${CI_PROJECT_NAME} namespace has a virtualService hostname add value to /etc/hosts
    - |
      if [ ! -z $(kubectl get services -n istio-system istio-ingressgateway -o jsonpath='{.status.loadBalancer.ingress[0].ip}' &> /dev/null) ] && [ ! -z $(kubectl get vs -A -o jsonpath='{.items[0].spec.hosts[0]}' &> /dev/null) ]; then
        echo "$(kubectl get services -n istio-system istio-ingressgateway -o jsonpath='{.status.loadBalancer.ingress[0].ip}') $(kubectl get vs -A -o jsonpath='{.items[*].spec.hosts[0]}')" >> /etc/hosts
      fi

    # Run Cypress tests
    - |
      if [ -f "tests/cypress.json" ]; then
        cypress run --project tests --browser chrome --headless
      fi

    # Run Helm Tests
    - |
      if [ -d "chart/templates/tests" ]; then
        helm test -n ${PACKAGE_NAMESPACE} ${PACKAGE_HELM_NAME} && export EXIT_CODE=$? || export EXIT_CODE=$?
        echo "***** Start Helm Test Logs *****"
        kubectl logs --tail=-1 -n ${PACKAGE_NAMESPACE} -l helm-test=enabled
        echo "***** End Helm Test Logs *****"
        if kubectl get configmap -n ${PACKAGE_NAMESPACE} cypress-screenshots &>/dev/null; then
          kubectl get configmap -n ${PACKAGE_NAMESPACE} cypress-screenshots -o jsonpath='{.data.cypress-screenshots\.tar\.gz\.b64}' > cypress-screenshots.tar.gz.b64
          cat cypress-screenshots.tar.gz.b64 | base64 -d > cypress-screenshots.tar.gz
          mkdir -p cypress-artifacts
          tar -zxf cypress-screenshots.tar.gz --strip-components=2 -C cypress-artifacts
        fi
        if kubectl get configmap -n ${PACKAGE_NAMESPACE} cypress-videos &>/dev/null; then
          kubectl get configmap -n ${PACKAGE_NAMESPACE} cypress-videos -o jsonpath='{.data.cypress-videos\.tar\.gz\.b64}' > cypress-videos.tar.gz.b64
          cat cypress-videos.tar.gz.b64 | base64 -d > cypress-videos.tar.gz
          mkdir -p cypress-artifacts
          tar -zxf cypress-videos.tar.gz --strip-components=2 -C cypress-artifacts
        fi
        if [[ ${EXIT_CODE} -ne 0 ]]; then
          exit ${EXIT_CODE}
        fi
      fi

    # File to indicate Job succeeded 
    - touch $CI_PROJECT_DIR/success

  after_script:
    - |
        if [ -e success ]; then
          echo "Job Succeeded"
        else
          echo "Job Failed Printing Debug Logs"
          echo "kubectl get all -A"
          kubectl get all -A
        fi
    # Fetch list of all images run
    - docker exec -i k3d-${CI_JOB_ID}-server-0 crictl images -o json | jq -r '.images[].repoTags[0] | select(. != null)' > images.txt
    # Remove istio and rancher upstream images
    - sed -i '/docker.io\/istio\//d' images.txt
    - sed -i '/docker.io\/rancher\//d' images.txt
    - |
      if [ -f tests/images.txt ]; then
        cat tests/images.txt >> images.txt
      fi
    # Delete Cluster
    - k3d cluster delete ${CI_JOB_ID}
    - docker network rm ${CI_JOB_ID}

  artifacts:
    when: always
    paths:
      - images.txt
      - tests/cypress/screenshots
      - tests/cypress/videos
      - cypress-artifacts
    expire_in: 3 days

package:
  stage: package
  extends:
    - .bigbang-dogfood
  image: registry.dso.mil/platform-one/big-bang/bigbang/synker:0.0.2
  rules:
    # run job for manual tag events or test-ci::release MRs, check for AWS access
    - if: '($CI_COMMIT_TAG && $AWS_ACCESS_KEY_ID) || ($CI_MERGE_REQUEST_LABELS =~ /(^|,)test-ci::release(,|$)/ && $TEST_AWS_ACCESS_KEY_ID)'
  before_script:
    # Set up auth
    - mkdir -p /root/.docker
    - |
      jq -n '{"auths": {"registry.dso.mil": {"auth": $bb_registry_auth}, "registry1.dso.mil": {"auth": $registry1_auth}, "registry.il2.dso.mil": {"auth": $il2_registry_auth} } }' \
        --arg bb_registry_auth ${BB_REGISTRY_AUTH} \
        --arg registry1_auth ${REGISTRY1_AUTH} \
        --arg il2_registry_auth ${IL2_REGISTRY_AUTH} > /root/.docker/config.json
  script:
    - |
      if [ -z ${PIPELINE_REPO_BRANCH} ]; then
        PIPELINE_REPO_BRANCH="$(yq e '.include[0].ref' ./.gitlab-ci.yml)"
        if [ -z ${PIPELINE_REPO_BRANCH} ]; then
          PIPELINE_REPO_BRANCH="master"
        fi
      fi
    - git clone -b ${PIPELINE_REPO_BRANCH} ${PIPELINE_REPO} ${PIPELINE_REPO_DESTINATION}
    - cp ${PIPELINE_REPO_DESTINATION}/jobs/release/synker.yaml ./synker.yaml
    # Populate images list in synker config
    - |
      for image in $(cat images.txt); do
        yq -i e "(.source.images |= . + \"${image}\")" "./synker.yaml"
      done
    - synker pull -b=1
    # Tar up synker as well
    - cp /usr/local/bin/synker synker.yaml /var/lib/registry/
    - tar -C /var/lib/registry -czvf $IMAGE_PKG .
    - tar -czvf $IMAGE_PKG /var/lib/registry
    # Package repos
    - mkdir -p repos/
    - |
      if [ -z ${CI_COMMIT_TAG} ]; then
        git -C repos/ clone -b ${CI_MERGE_REQUEST_SOURCE_BRANCH_NAME} ${CI_REPOSITORY_URL}
      else
        git -C repos/ clone -b ${CI_COMMIT_TAG} ${CI_REPOSITORY_URL}
      fi
    - |
      if [ -f tests/dependencies.yaml ]; then
        yq e ".*.git | path | .[-2]" "tests/dependencies.yaml" | while IFS= read -r i; do
          dep_branch=$(yq e ".${i}.git.tag" "tests/dependencies.yaml")
          if [[ -z ${dep_branch} || ${dep_branch} == "null" ]]; then
            dep_branch=$(yq e ".${i}.branch" "tests/dependencies.yaml")
          fi

          dep_repo=$(yq e ".${i}.git.repo" "tests/dependencies.yaml")
          if [[ -z ${dep_repo} || ${dep_repo} == "null" ]]; then
            dep_repo=$(yq e ".${i}.git" "tests/dependencies.yaml")
            if [[ -z ${dep_repo} || ${dep_repo} == "null" ]]; then
              continue
            fi
          fi

          if [[ -z ${dep_branch} || ${dep_branch} == "null" ]]; then
            git -C repos/ clone ${dep_repo}
          else
            git -C repos/ clone -b ${dep_branch} ${dep_repo}
          fi
        done
      fi
    - tar -czf $REPOS_PKG repos/
    # Prep release
    - mkdir -p release
    - mv $IMAGE_LIST $IMAGE_PKG $REPOS_PKG release/
    # Publish packages to s3 release
    - |
      if [ -z $CI_COMMIT_TAG ]; then
        aws configure set aws_region ${TEST_AWS_DEFAULT_REGION}
        aws configure set aws_access_key_id ${TEST_AWS_ACCESS_KEY_ID}
        aws configure set aws_secret_access_key ${TEST_AWS_SECRET_ACCESS_KEY}
        aws s3 cp --quiet release/${IMAGE_LIST} s3://${RELEASE_BUCKET}/tests/${CI_PROJECT_NAME}/${CI_COMMIT_SHA}/
        aws s3 cp --quiet release/${IMAGE_PKG} s3://${RELEASE_BUCKET}/tests/${CI_PROJECT_NAME}/${CI_COMMIT_SHA}/
        aws s3 cp --quiet release/${REPOS_PKG} s3://${RELEASE_BUCKET}/tests/${CI_PROJECT_NAME}/${CI_COMMIT_SHA}/
      else
        aws s3 sync --quiet release/ s3://${RELEASE_BUCKET}/packages/${CI_PROJECT_NAME}/${CI_COMMIT_TAG}
      fi
    # Get release notes from CHANGELOG
    - echo "# RELEASE NOTES:" >> release_notes.txt
    - |
      if [ -z $CI_COMMIT_TAG ]; then
        echo "Please see the repo [documentation](${CI_PROJECT_URL}/-/tree/${CI_COMMIT_SHA}/docs) for additional info on this package." >> release_notes.txt
      else
        echo "Please see the repo [documentation](${CI_PROJECT_URL}/-/tree/${CI_COMMIT_TAG}/docs) for additional info on this package." >> release_notes.txt
      fi
    - release_notes=$(cat CHANGELOG.md | sed  "1,/## \[${CI_COMMIT_TAG}]/d;/## \[/Q")
    - |
      if [[ -z $release_notes ]]; then
        printf "\n" >> release_notes.txt;
        echo "NO ENTRY IN CHANGELOG FOR THIS TAG, ADD RELEASE NOTES HERE" >> release_notes.txt;
      else
        printf "\n" >> release_notes.txt;
        echo "${release_notes}" >> release_notes.txt;
      fi
  artifacts:
    paths:
      - release_notes.txt
    expire_in: 3 days

release:
  stage: release
  extends:
    - .bigbang-dogfood
  image: registry.gitlab.com/gitlab-org/release-cli:latest
  rules:
    # run job for manual tag events or test-ci::release MRs, check for AWS access
    - if: '($CI_COMMIT_TAG && $AWS_ACCESS_KEY_ID) || ($CI_MERGE_REQUEST_LABELS =~ /(^|,)test-ci::release(,|$)/ && $TEST_AWS_ACCESS_KEY_ID)'
  variables:
    RELEASE_ENDPOINT: https://${RELEASE_BUCKET}.s3-${AWS_DEFAULT_REGION}.amazonaws.com/packages/${CI_PROJECT_NAME}/${CI_COMMIT_TAG}
  script:
    # Use release-cli to cut a release in Gitlab or simulate a dry-run & print asset links
    - |
      if [ -z $CI_COMMIT_TAG ]; then
        RELEASE_ENDPOINT="https://${RELEASE_BUCKET}.s3-${TEST_AWS_DEFAULT_REGION}.amazonaws.com/tests/${CI_PROJECT_NAME}/${CI_COMMIT_SHA}"
        printf "Release will run: \n\
          release-cli create --name \"\${RELEASE_NAME} \${CI_COMMIT_SHA}\" --tag-name \${CI_COMMIT_SHA} \n\
            --description \"\$(cat release_notes.txt)\" \n\
            --assets-link \"{\"name\":\"${IMAGE_LIST}\",\"url\":\"${RELEASE_ENDPOINT}/${IMAGE_LIST}\"}\" \n\
            --assets-link \"{\"name\":\"${IMAGE_PKG}\",\"url\":\"${RELEASE_ENDPOINT}/${IMAGE_PKG}\"}\" \n\
            --assets-link \"{\"name\":\"${REPOS_PKG}\",\"url\":\"${RELEASE_ENDPOINT}/${REPOS_PKG}\"}\"\n"
      else
        release-cli create --name "${RELEASE_NAME} ${CI_COMMIT_TAG}" --tag-name ${CI_COMMIT_TAG} \
          --description "$(cat release_notes.txt)" \
          --assets-link "{\"name\":\"${IMAGE_LIST}\",\"url\":\"${RELEASE_ENDPOINT}/${IMAGE_LIST}\"}" \
          --assets-link "{\"name\":\"${IMAGE_PKG}\",\"url\":\"${RELEASE_ENDPOINT}/${IMAGE_PKG}\"}" \
          --assets-link "{\"name\":\"${REPOS_PKG}\",\"url\":\"${RELEASE_ENDPOINT}/${REPOS_PKG}\"}"
      fi
