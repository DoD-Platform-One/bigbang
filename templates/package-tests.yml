# global rules for when pipelines run
workflow:
  rules:
    # run pipeline for manual tag events
    - if: $CI_COMMIT_TAG
    # run pipeline on merge request events
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    # run pipeline on commits to default branch
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    # skip pipeline for branches that start with "docs"
    - if: '$CI_COMMIT_REF_NAME =~ /^doc*/i'
      when: never

stages:
  - configuration validation
  - package tests
  - package
  - release

variables:
  PIPELINE_REPO: https://repo1.dso.mil/platform-one/big-bang/pipeline-templates/pipeline-templates.git
  PIPELINE_REPO_DESTINATION: "../pipeline-repo"
  IMAGE_LIST: images.txt
  IMAGE_PKG: images.tar.gz
  REPOS_PKG: repositories.tar.gz
  RELEASE_NAME: ${CI_PROJECT_NAME}
  RELEASE_BUCKET: umbrella-bigbang-releases
  PACKAGE_NAMESPACE: ${CI_PROJECT_NAME}
  PACKAGE_HELM_NAME: ${CI_PROJECT_NAME}

.bigbang-dogfood:
  tags:
    - bigbang
    - dogfood
    - generic

configuration validation:
  image: registry.dso.mil/platform-one/big-bang/pipeline-templates/pipeline-templates/k3d-builder:0.0.9
  stage: configuration validation
  extends:
    - .bigbang-dogfood
  variables:
    GENERIC_POLICY_PATH: "${PIPELINE_REPO_DESTINATION}/policies"

  before_script:
    - |
      if [ -z ${PIPELINE_REPO_BRANCH} ]; then
        PIPELINE_REPO_BRANCH="$(yq e '.include[0].ref' ./.gitlab-ci.yml)"
        if [ -z ${PIPELINE_REPO_BRANCH} ]; then
          PIPELINE_REPO_BRANCH="master"
        fi
      fi
    - git clone -b ${PIPELINE_REPO_BRANCH} ${PIPELINE_REPO} ${PIPELINE_REPO_DESTINATION}
  script:
    # Place configuration validation tests here
    - echo -e "\e[0Ksection_start:`date +%s`:package_tree[collapsed=true]\r\e[0KPackage Directory Structure"
    - tree .
    - echo -e "\e[0Ksection_end:`date +%s`:package_tree\r\e[0K"

    # Global policy tests
    - echo -e "\e[0Ksection_start:`date +%s`:generic_policy_tests[collapsed=true]\r\e[0KGlobal Policy Tests"
    - |
      if [ $(ls -1 tests/test-values.y*ml 2>/dev/null | wc -l) -gt 0 ]; then
        echo "Checking test values..."
        helm conftest chart --policy ${GENERIC_POLICY_PATH} -f tests/test-values.y*ml
        echo "Checking chart values..."
        helm conftest chart --policy ${GENERIC_POLICY_PATH}
      else
        helm conftest chart --policy ${GENERIC_POLICY_PATH}
      fi
    - echo -e "\e[0Ksection_end:`date +%s`:generic_policy_tests\r\e[0K"

    # Package specific tests
    - echo -e "\e[0Ksection_start:`date +%s`:package_specific_tests[collapsed=true]\r\e[0KPackage Specific Tests"
    - |
      if [ -d "tests/policy" ]; then
        echo "App specific configuration validation tests:"
        if [ $(ls -1 tests/test-values.y*ml 2>/dev/null | wc -l) -gt 0 ]; then
          echo "Checking test values..."
          helm conftest chart --policy tests/policy -f tests/test-values.y*ml
          echo "Checking chart values..."
          helm conftest chart --policy tests/policy
        else
          helm conftest chart --policy tests/policy
        fi
      fi
    - echo -e "\e[0Ksection_end:`date +%s`:package_specific_tests\r\e[0K"

    # Package API Deprecation Check
    - echo -e "\e[0Ksection_start:`date +%s`:package_deprecation_check[collapsed=true]\r\e[0KPackage API Deprecation Check"
    - helm template ${PACKAGE_HELM_NAME} chart -n ${PACKAGE_NAMESPACE} --set monitoring.enabled=true --set istio.enabled=true --set networkPolicies.enabled=true -f tests/test-values.y*ml | pluto detect -owide - && export EXIT_CODE=$? || export EXIT_CODE=$?
    - |
      if [[ ${EXIT_CODE} -eq 2 ]]; then
        echo -e "\e[31mNOTICE: A deprecated apiVersion has been found.\e[0m"
        exit ${EXIT_CODE}
      elif [[ ${EXIT_CODE} -eq 3 ]]; then
        echo -e "\e[31mNOTICE: A removed apiVersion has been found.\e[0m"
        exit ${EXIT_CODE}
      else
        exit ${EXIT_CODE}
      fi
    - echo -e "\e[0Ksection_end:`date +%s`:package_deprecation_check\r\e[0K"
  allow_failure:
    exit_codes:
      - 2
      - 3
  retry:
    max: 2
    when:
      - unknown_failure
      - stuck_or_timeout_failure
      - runner_system_failure

chart update check:
  image: registry.dso.mil/platform-one/big-bang/pipeline-templates/pipeline-templates/k3d-builder:0.0.9
  stage: configuration validation
  extends:
    - .bigbang-dogfood
  rules:
    # skip job when MR title contains 'SKIP UPDATE CHECK'
    - if: '$CI_MERGE_REQUEST_TITLE =~ /SKIP UPDATE CHECK/'
      when: never
    # run pipeline on merge request events
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
  script:
    # change to target branch and check if Chart.yaml or Changelog missing. If so, check source.
    - echo -e "\e[0Ksection_start:`date +%s`:chart_changelog_checks[collapsed=true]\r\e[0KHeader Searching for Chart.yaml/CHANGELOG mismatches"
    - git fetch && git checkout ${CI_MERGE_REQUEST_TARGET_BRANCH_NAME}
    - |
      if [ ! -f "chart/Chart.yaml" ] || [ ! -f "CHANGELOG.md" ]; then
        # change to source branch and check if Chart.yaml or Changelog missing. If one or both are missing, fail.
        git fetch && git checkout ${CI_MERGE_REQUEST_SOURCE_BRANCH_NAME}
        if [ ! -f "chart/Chart.yaml" ] || [ ! -f "CHANGELOG.md" ]; then
          echo -e "\e[0Ksection_end:`date +%s`:chart_changelog_checks\r\e[0K"
          echo -e "\e[31mFAIL: Package must have chart/Chart.yaml and CHANGELOG.md\e[0m"
          exit 1
        else
          # target branch is missing Chart.yaml or Changelog. Exit with notice.
          echo -e "\e[0Ksection_end:`date +%s`:chart_changelog_checks\r\e[0K"
          echo -e "\e[31mNOTICE: Chart.yaml or Changelog not found in ${CI_MERGE_REQUEST_TARGET_BRANCH_NAME}, skipping update check\e[0m"
          exit 0
        fi
        # return to target branch
        git fetch && git checkout ${CI_MERGE_REQUEST_TARGET_BRANCH_NAME}
      fi
    - cp CHANGELOG.md /tmp/CHANGELOG.md
    - echo -e "\e[0Ksection_end:`date +%s`:chart_changelog_checks\r\e[0K"
    - DEFAULT_BRANCH_VERSION=$(yq e '.version' chart/Chart.yaml)
    - echo "Old Chart Version:$DEFAULT_BRANCH_VERSION"
    - echo -e "\e[0Ksection_start:`date +%s`:package_checkout2[collapsed=true]\r\e[0KPackage MR Checkout"
    - git reset --hard && git clean -fd
    - git checkout ${CI_MERGE_REQUEST_SOURCE_BRANCH_NAME}
    - echo -e "\e[0Ksection_end:`date +%s`:package_checkout2\r\e[0K"
    - MR_BRANCH_VERSION=$(yq e '.version' chart/Chart.yaml)
    - echo "New Chart Version:$MR_BRANCH_VERSION"
    # 'test="Version: $MR_BRANCH_VERSION"'
    - README_BRANCH_VERSION=$(cat README.md | egrep "test")
    # README_BRANCH_VERSION=$(grep -E $test 'README.md')
    # cat README.md
    # cat README.md | grep -E "Version"
    # cat README.md | grep -E "Version:\s $MR_BRANCH_VERSION"
    - echo "New README Version:$README_BRANCH_VERSION"
    - |
      if [ "$MR_BRANCH_VERSION" == "$DEFAULT_BRANCH_VERSION" ]; then
        echo -e "\e[31mNOTICE: You need to bump chart version in Chart.yaml\e[0m"
        EXIT="true"
      fi
      if [ -z "$README_BRANCH_VERSION" ]; then
        echo -e "\e[31mNOTICE: You need to bump chart version in README.md - for template, see: https://repo1.dso.mil/platform-one/big-bang/apps/library-charts/gluon/-/blob/master/docs/bb-package-readme.md\e[0m"
        EXIT="true"
      fi
      if [ "$(cat /tmp/CHANGELOG.md)" == "$(cat CHANGELOG.md)" ] ; then
        echo -e "\e[31mNOTICE: You need to update CHANGELOG.md\e[0m"
        EXIT="true"
      fi
      if [ "$EXIT" == "true" ]; then
        exit 1
      fi
  retry:
    max: 2
    when:
      - unknown_failure
      - stuck_or_timeout_failure
      - runner_system_failure

.k3d-ci:
  image: registry.dso.mil/platform-one/big-bang/pipeline-templates/pipeline-templates/k3d-builder:0.0.9
  tags:
    - bigbang
    - privileged
    - dogfood
    - packages
  variables:
    DOCKER_HOST: tcp://localhost:2376
    DOCKER_TLS_CERTDIR: "/certs"
    DOCKER_TLS_VERIFY: 1
    DOCKER_CERT_PATH: "$DOCKER_TLS_CERTDIR/client"
    DOCKER_DRIVER: overlay2
    WAIT_PATH: "${PIPELINE_REPO_DESTINATION}/jobs/wait/wait.sh"
    K3D_CONFIG_PATH: "${PIPELINE_REPO_DESTINATION}/jobs/k3d-ci/config.yaml"

  before_script:
    - echo -e "\e[0Ksection_start:`date +%s`:cluster_setup[collapsed=true]\r\e[0KCluster Setup"
    # Clone pipeline repo for waits & k3d config
    - |
      if [ -z ${PIPELINE_REPO_BRANCH} ]; then
        PIPELINE_REPO_BRANCH="$(yq e '.include[0].ref' ./.gitlab-ci.yml)"
        if [ -z ${PIPELINE_REPO_BRANCH} ]; then
          PIPELINE_REPO_BRANCH="master"
        fi
      fi
    - git clone -b ${PIPELINE_REPO_BRANCH} ${PIPELINE_REPO} ${PIPELINE_REPO_DESTINATION}
    - source ${WAIT_PATH}

    # Give docker-in-docker time to come alive
    - i=0; while [ "$i" -lt 12 ]; do docker info &>/dev/null && break; sleep 5; i=$(( i + 1 )) ; done

    # Create docker network and cluster
    - docker network create ${CI_JOB_ID} --driver=bridge -o "com.docker.network.driver.mtu"="1450"
    - k3d cluster create ${CI_JOB_ID} --config ${K3D_CONFIG_PATH} --network ${CI_JOB_ID}
    - until kubectl get deployment coredns -n kube-system -o go-template='{{.status.availableReplicas}}' | grep -v -e '<no value>'; do sleep 1s; done

    # Setup pull secrets for project
    - |
      if [ ! -z ${PROJECT_NAME} ]; then
        if [ ${PACKAGE_NAMESPACE} == ${CI_PROJECT_NAME} ]; then
          PACKAGE_NAMESPACE=${PROJECT_NAME}
        fi
      fi
      kubectl create namespace ${PACKAGE_NAMESPACE}
      kubectl create -n ${PACKAGE_NAMESPACE} secret docker-registry private-registry --docker-server="https://registry1.dso.mil" --docker-username='robot$bb-dev-imagepullonly' --docker-password="${REGISTRY1_PASSWORD}"
      kubectl create -n ${PACKAGE_NAMESPACE} secret docker-registry private-registry-mil --docker-server="https://registry1.dso.mil" --docker-username='robot$bb-dev-imagepullonly' --docker-password="${REGISTRY1_PASSWORD}"
    - echo -e "\e[0Ksection_end:`date +%s`:cluster_setup\r\e[0K"

  after_script:
    - |
      if [ -e success ]; then
        echo -e "\e[0Ksection_start:`date +%s`:cluster_status[collapsed=true]\r\e[0KCluster Status"
        echo "Job Succeeded, cluster status:"
        kubectl get all -A
        echo -e "\e[0Ksection_end:`date +%s`:cluster_status\r\e[0K"
      else
        echo "Job Failed, cluster status:"
        kubectl get all -A
      fi
    # Delete Cluster
    - echo -e "\e[0Ksection_start:`date +%s`:cluster_clean[collapsed=true]\r\e[0KCluster Cleanup"
    - k3d cluster delete ${CI_JOB_ID}
    - docker network rm ${CI_JOB_ID}
    - echo -e "\e[0Ksection_end:`date +%s`:cluster_clean\r\e[0K"

  artifacts:
    when: always
    paths:
      - images.txt
      - tests/cypress/screenshots
      - tests/cypress/videos
      - cypress-artifacts
    expire_in: 3 days

.dependency_install: &dependency_install
  - |
    if [ -f "tests/dependencies.yaml" ]; then
      yq e ".*.git | path | .[-2]" "tests/dependencies.yaml" | while IFS= read -r i; do
        dep_name=$i

        dep_repo=$(yq e ".${i}.git.repo" "tests/dependencies.yaml")
        if [[ -z ${dep_repo} || ${dep_repo} == "null" ]]; then
          dep_repo=$(yq e ".${i}.git" "tests/dependencies.yaml")
          if [[ -z ${dep_repo} || ${dep_repo} == "null" ]]; then
            continue
          fi
        fi

        dep_branch=$(yq e ".${i}.git.tag" "tests/dependencies.yaml")
        if [[ -z ${dep_branch} || ${dep_branch} == "null" ]]; then
          dep_branch=$(yq e ".${i}.branch" "tests/dependencies.yaml")
        fi

        dep_namespace=$(yq e ".${i}.namespace" "tests/dependencies.yaml")
        if [[ -z ${dep_namespace} || ${dep_namespace} == "null" ]]; then
          dep_namespace=$dep_name
        fi

        dep_helm_name=$(yq e ".${i}.package-name" "tests/dependencies.yaml")
        if [[ -z ${dep_helm_name} || ${dep_helm_name} == "null" ]]; then
          dep_helm_name=$dep_name
        fi

        if [[ -d ${dep_branch} || ${dep_branch} == "null" ]]; then
          if [[ -d "repos/${dep_name}" ]]; then
            echo "Checking out default branch from ${dep_repo}"
            cd repos/${dep_name}
            git reset --hard && git clean -fd
            git checkout $(git remote show origin | awk '/HEAD branch/ {print $NF}')
            cd ../../
          else
            echo "Cloning default branch from ${dep_repo}"
            git clone ${dep_repo} repos/${dep_name}
          fi
        else
          if [[ -d "repos/${dep_name}" ]]; then
            echo "Checking out ${dep_branch} from ${dep_repo}"
            cd repos/${dep_name}
            git reset --hard && git clean -fd
            git checkout ${dep_branch}
            cd ../../
          else
            echo "Cloning ${dep_branch} from ${dep_repo}"
            git clone -b ${dep_branch} ${dep_repo} repos/${dep_name}
          fi
        fi

        echo "Installing dependency: repos/${dep_name} into ${dep_namespace} namespace"
        if ! kubectl get namespace ${dep_namespace} 2> /dev/null; then
          kubectl create namespace ${dep_namespace};
        fi
        if ! kubectl get secret -n ${dep_namespace} private-registry 2> /dev/null; then
          kubectl create -n ${dep_namespace} secret docker-registry private-registry --docker-server="https://registry1.dso.mil" --docker-username='robot$bb-dev-imagepullonly' --docker-password="${REGISTRY1_PASSWORD}"
        fi

        if ! kubectl get secret -n ${dep_namespace} private-registry-mil 2> /dev/null; then
          kubectl create -n ${dep_namespace} secret docker-registry private-registry-mil --docker-server="https://registry1.dso.mil" --docker-username='robot$bb-dev-imagepullonly' --docker-password="${REGISTRY1_PASSWORD}"
        fi

        if [ $(ls -1 repos/${dep_name}/tests/test-values.y*ml 2>/dev/null | wc -l) -gt 0 ]; then
          echo "Helm installing repos/${dep_name}/chart into ${dep_namespace} namespace using repos/${dep_name}/tests/test-values.yaml for values"
          helm upgrade -i --wait --timeout 600s ${dep_helm_name} repos/${dep_name}/chart -n ${dep_namespace} -f repos/${dep_name}/tests/test-values.y*ml --set istio.enabled=false
        else
          echo "Helm installing repos/${dep_name}/chart into ${dep_namespace} namespace using default values"
          helm upgrade -i --wait --timeout 600s ${dep_helm_name} repos/${dep_name}/chart -n ${dep_namespace} --set istio.enabled=false
        fi
      done
    fi

.dependency_wait: &dependency_wait
  - |
    if [ -f "tests/dependencies.yaml" ]; then
      sleep 10
      echo -n "Waiting on CRDS ... "
      kubectl wait --for=condition=established --timeout 60s -A crd --all > /dev/null
      echo "done."
      if [ -f tests/dependencies.yaml ]; then
        yq e ".*.git | path | .[-2]" "tests/dependencies.yaml" | while IFS= read -r i; do
          dep_name=$i
          if [ -f repos/${dep_name}/tests/wait.sh ]; then
            source repos/${dep_name}/tests/wait.sh
            echo -n "Waiting on dependency resources ... "
            wait_project
            echo "done."
          fi
        done
      fi
      echo -n "Waiting on stateful sets ... "
      wait_sts
      echo "done."
      echo -n "Waiting on daemon sets ... "
      wait_daemonset
      echo "done."
      echo -n "Waiting on deployments ... "
      kubectl wait --for=condition=available --timeout 600s -A deployment --all > /dev/null
      echo "done."
      echo -n "Waiting on terminating pods ... "
      readarray -t DELPODS < <(kubectl get pods -A -o jsonpath='{range .items[?(@.metadata.deletionTimestamp)]}{@.metadata.namespace}{" "}{@.metadata.name}{"\n"}{end}')
      for DELPOD in "${DELPODS[@]}"; do kubectl wait --for=delete --timeout 60s pod -n $DELPOD > /dev/null; done
      echo "done."
      echo -n "Waiting on running pods to be ready ... "
      kubectl wait --for=condition=ready --timeout 600s -A pods --all --field-selector status.phase=Running > /dev/null
      echo "done."
    fi

.package_install: &package_install
  - |
    if [ ! -z ${PROJECT_NAME} ]; then
      if [ ${PACKAGE_HELM_NAME} == ${CI_PROJECT_NAME} ]; then
        PACKAGE_HELM_NAME=${PROJECT_NAME}
      fi
    fi
    if [ $(ls -1 tests/test-values.y*ml 2>/dev/null | wc -l) -gt 0 ]; then
      echo "Helm installing ${CI_PROJECT_NAME}/chart into ${PACKAGE_NAMESPACE} namespace using ${CI_PROJECT_NAME}/tests/test-values.yaml for values"
      helm upgrade -i --wait --timeout 600s ${PACKAGE_HELM_NAME} chart -n ${PACKAGE_NAMESPACE} -f tests/test-values.y*ml --set istio.enabled=false
    else
      echo "Helm installing ${CI_PROJECT_NAME}/chart into ${PACKAGE_NAMESPACE} namespace using default values"
      helm upgrade -i --wait --timeout 600s ${PACKAGE_HELM_NAME} chart -n ${PACKAGE_NAMESPACE} --set istio.enabled=false
    fi

.package_wait: &package_wait
  - |
    sleep 10
    echo -n "Waiting on CRDs ... "
    kubectl wait --for=condition=established --timeout 60s -A crd --all > /dev/null
    echo "done."
    if [ -f tests/wait.sh ]; then
      source tests/wait.sh
      echo -n "Waiting on project resources ... "
      wait_project
      echo "done."
    fi
    echo -n "Waiting on stateful sets ... "
    wait_sts
    echo "done."
    echo -n "Waiting on daemon sets ... "
    wait_daemonset
    echo "done."
    echo -n "Waiting on deployments ... "
    kubectl wait --for=condition=available --timeout 600s -A deployment --all > /dev/null
    echo "done."
    echo -n "Waiting on terminating pods ... "
    readarray -t DELPODS < <(kubectl get pods -A -o jsonpath='{range .items[?(@.metadata.deletionTimestamp)]}{@.metadata.namespace}{" "}{@.metadata.name}{"\n"}{end}')
    for DELPOD in "${DELPODS[@]}"; do kubectl wait --for=delete --timeout 60s pod -n $DELPOD > /dev/null; done
    echo "done."
    echo -n "Waiting on running pods to be ready ... "
    kubectl wait --for=condition=ready --timeout 600s -A pods --all --field-selector status.phase=Running > /dev/null
    echo "done."

.package_test: &package_test
  - |
    if [ -d "chart/templates/tests" ]; then
      helm test -n ${PACKAGE_NAMESPACE} ${PACKAGE_HELM_NAME} && export EXIT_CODE=$? || export EXIT_CODE=$?
      echo "***** Start Helm Test Logs *****"
      kubectl logs --tail=-1 -n ${PACKAGE_NAMESPACE} -l helm-test=enabled
      echo "***** End Helm Test Logs *****"
      if kubectl get configmap -n ${PACKAGE_NAMESPACE} cypress-screenshots &>/dev/null; then
        kubectl get configmap -n ${PACKAGE_NAMESPACE} cypress-screenshots -o jsonpath='{.data.cypress-screenshots\.tar\.gz\.b64}' > cypress-screenshots.tar.gz.b64
        cat cypress-screenshots.tar.gz.b64 | base64 -d > cypress-screenshots.tar.gz
        mkdir -p cypress-artifacts
        tar -zxf cypress-screenshots.tar.gz --strip-components=2 -C cypress-artifacts
      fi
      if kubectl get configmap -n ${PACKAGE_NAMESPACE} cypress-videos &>/dev/null; then
        kubectl get configmap -n ${PACKAGE_NAMESPACE} cypress-videos -o jsonpath='{.data.cypress-videos\.tar\.gz\.b64}' > cypress-videos.tar.gz.b64
        cat cypress-videos.tar.gz.b64 | base64 -d > cypress-videos.tar.gz
        mkdir -p cypress-artifacts
        tar -zxf cypress-videos.tar.gz --strip-components=2 -C cypress-artifacts
      fi
      if [[ ${EXIT_CODE} -ne 0 ]]; then
        exit ${EXIT_CODE}
      fi
    fi

# Note: This section is temporarily duplicated to allow upgrade testing to fail if tests were not built to handle subsuquent runs
# Due to some of the quirks with Gitlab CI "script blocks" this is the easiest solution
# This block should be removed in the future and line 397 updated to just call `package_test`
.package_upgrade_test: &package_upgrade_test
  - |
    if [ -d "chart/templates/tests" ]; then
      helm test -n ${PACKAGE_NAMESPACE} ${PACKAGE_HELM_NAME} && export EXIT_CODE=$? || export EXIT_CODE=$?
      echo "***** Start Helm Test Logs *****"
      kubectl logs --tail=-1 -n ${PACKAGE_NAMESPACE} -l helm-test=enabled
      echo "***** End Helm Test Logs *****"
      if kubectl get configmap -n ${PACKAGE_NAMESPACE} cypress-screenshots &>/dev/null; then
        kubectl get configmap -n ${PACKAGE_NAMESPACE} cypress-screenshots -o jsonpath='{.data.cypress-screenshots\.tar\.gz\.b64}' > cypress-screenshots.tar.gz.b64
        cat cypress-screenshots.tar.gz.b64 | base64 -d > cypress-screenshots.tar.gz
        mkdir -p cypress-artifacts
        tar -zxf cypress-screenshots.tar.gz --strip-components=2 -C cypress-artifacts
      fi
      if kubectl get configmap -n ${PACKAGE_NAMESPACE} cypress-videos &>/dev/null; then
        kubectl get configmap -n ${PACKAGE_NAMESPACE} cypress-videos -o jsonpath='{.data.cypress-videos\.tar\.gz\.b64}' > cypress-videos.tar.gz.b64
        cat cypress-videos.tar.gz.b64 | base64 -d > cypress-videos.tar.gz
        mkdir -p cypress-artifacts
        tar -zxf cypress-videos.tar.gz --strip-components=2 -C cypress-artifacts
      fi
      if [[ ${EXIT_CODE} -ne 0 ]]; then
        echo -e "\e[31mNOTICE to MR creators/reviewers: There were errors on upgrade testing. If this package's tests are expected to fail when run twice in a row, please open a ticket to resolve this for the future.\e[0m"
        echo -e "\e[31mOtherwise, take note of artifacts and testing results and ensure that the upgrade path is functional before approving/merging.\e[0m"
        exit 123
      fi
    fi

.deprecation_check: &deprecation_check
  - echo -e "\e[0Ksection_start:`date +%s`:kubent_check[collapsed=true]\r\e[0KIn Cluster Deprecation Check"
  - kubent -e || export EXIT_CODE=$?
  - |
    if [ $EXIT_CODE -eq 200 ]; then 
      echo -e "\e[31mNOTICE: API deprecations or removals were found.\e[0m"
      exit 200
    fi
  - echo -e "\e[0Ksection_end:`date +%s`:kubent_check\r\e[0K"

clean install:
  stage: package tests
  extends:
    - .k3d-ci
  script:
    - echo -e "\e[0Ksection_start:`date +%s`:dependency_clean[collapsed=true]\r\e[0KDependency Install and Wait"
    - *dependency_install
    - *dependency_wait
    # Pull initial list of image dependencies that we will want to remove from the final images.txt
    # (retry up to 6x)
    - deps=$(timeout 65 bash -c "until docker exec -i k3d-${CI_JOB_ID}-server-0 crictl images -o json; do sleep 10; done;")
    - echo $deps | jq -r '.images[].repoTags[0] | select(. != null)' | tee dependencies.txt
    - echo -e "\e[0Ksection_end:`date +%s`:dependency_clean\r\e[0K"
    - *package_install
    - *package_wait
    # Once package installed, pull another list of images. List will include dependencies and package images.
    # (retry up to 6x)
    - echo -e "\e[0Ksection_start:`date +%s`:image_fetch[collapsed=true]\r\e[0KFetch Images"
    - images=$(timeout 65 bash -c "until docker exec -i k3d-${CI_JOB_ID}-server-0 crictl images -o json; do sleep 10; done;")
    - echo $images | jq -r '.images[].repoTags[0] | select(. != null)' | tee full-list.txt
    ## Create final images.txt: Remove items from the dependencies list from the full-list.
    - grep -Fxvf dependencies.txt full-list.txt | tee images.txt
    # Remove rancher upstream images. The k3d cluster will inject images for various purposes like load balancers, PVCs, etc. 
    # If we don't explicitly filter those out there's the potential that they sneak in
    - sed -i '/docker.io\/rancher\//d' images.txt
    - |
      if [ -f tests/images.txt ]; then
        cat tests/images.txt >> images.txt
      fi
    - echo -e "\e[0Ksection_end:`date +%s`:image_fetch\r\e[0K"
    - *package_test
    - *deprecation_check
    - touch $CI_PROJECT_DIR/success


  allow_failure:
    exit_codes: 200
  retry:
    max: 2
    when:
      - unknown_failure
      - stuck_or_timeout_failure
      - runner_system_failure

upgrade:
  stage: package tests
  extends:
    - .k3d-ci
  rules:
    # skip job when MR title contains 'SKIP UPGRADE'
    - if: '$CI_MERGE_REQUEST_TITLE =~ /SKIP UPGRADE/'
      when: never
    # skip pipeline for branches that start with "docs"
    - if: '$CI_COMMIT_REF_NAME =~ /^doc*/i'
      when: never
    # run pipeline on merge request events
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
  script:
    - echo "Installing ${CI_PROJECT_NAME} from ${CI_MERGE_REQUEST_TARGET_BRANCH_NAME}"
    - echo -e "\e[0Ksection_start:`date +%s`:package_checkout1[collapsed=true]\r\e[0KPackage Checkout"
    - git fetch && git checkout ${CI_MERGE_REQUEST_TARGET_BRANCH_NAME}
    - echo -e "\e[0Ksection_end:`date +%s`:package_checkout1\r\e[0K"
    - echo -e "\e[0Ksection_start:`date +%s`:dependency_up1[collapsed=true]\r\e[0KDependency Install and Wait"
    - *dependency_install
    - *dependency_wait
    - echo -e "\e[0Ksection_end:`date +%s`:dependency_up1\r\e[0K"
    - *package_install
    - *package_wait
    - *package_test
    - echo "Upgrading ${CI_PROJECT_NAME} to ${CI_MERGE_REQUEST_SOURCE_BRANCH_NAME}"
    - echo -e "\e[0Ksection_start:`date +%s`:package_checkout2[collapsed=true]\r\e[0KPackage Upgrade Checkout"
    - git reset --hard && git clean -fd
    - git checkout ${CI_MERGE_REQUEST_SOURCE_BRANCH_NAME}
    - echo -e "\e[0Ksection_end:`date +%s`:package_checkout2\r\e[0K"
    - echo -e "\e[0Ksection_start:`date +%s`:dependency_up2[collapsed=true]\r\e[0KDependency Upgrade and Wait"
    - *dependency_install
    - *dependency_wait
    - echo -e "\e[0Ksection_end:`date +%s`:dependency_up2\r\e[0K"
    - *package_install
    - *package_wait
    - *package_upgrade_test
    - *deprecation_check
    - touch $CI_PROJECT_DIR/success
  allow_failure:
    exit_codes: 
      - 123
      - 200
  retry:
    max: 2
    when:
      - unknown_failure
      - stuck_or_timeout_failure
      - runner_system_failure

package:
  stage: package
  extends:
    - .bigbang-dogfood
  image: registry.dso.mil/platform-one/big-bang/bigbang/synker:0.0.2
  rules:
    # run job for manual tag events or test-ci::release MRs, check for AWS access
    - if: '($CI_COMMIT_TAG && $AWS_ACCESS_KEY_ID) || ($CI_MERGE_REQUEST_LABELS =~ /(^|,)test-ci::release(,|$)/ && $TEST_AWS_ACCESS_KEY_ID)'
  before_script:
    # Set up auth
    - mkdir -p /root/.docker
    - |
      jq -n '{"auths": {"registry.dso.mil": {"auth": $bb_registry_auth}, "registry1.dso.mil": {"auth": $registry1_auth}, "registry.il2.dso.mil": {"auth": $il2_registry_auth} } }' \
        --arg bb_registry_auth ${BB_REGISTRY_AUTH} \
        --arg registry1_auth ${REGISTRY1_AUTH} \
        --arg il2_registry_auth ${IL2_REGISTRY_AUTH} > /root/.docker/config.json
  script:
    - |
      if [ -z ${PIPELINE_REPO_BRANCH} ]; then
        PIPELINE_REPO_BRANCH="$(yq e '.include[0].ref' ./.gitlab-ci.yml)"
        if [ -z ${PIPELINE_REPO_BRANCH} ]; then
          PIPELINE_REPO_BRANCH="master"
        fi
      fi
    - git clone -b ${PIPELINE_REPO_BRANCH} ${PIPELINE_REPO} ${PIPELINE_REPO_DESTINATION}
    - cp ${PIPELINE_REPO_DESTINATION}/jobs/release/synker.yaml ./synker.yaml
    # Populate images list in synker config
    - |
      for image in $(cat images.txt); do
        yq -i e "(.source.images |= . + \"${image}\")" "./synker.yaml"
      done
    - synker pull -b=1
    # Tar up synker as well
    - cp /usr/local/bin/synker synker.yaml /var/lib/registry/
    - tar -czvf $IMAGE_PKG /var/lib/registry
    # Package repos
    - mkdir -p repos/
    - |
      if [ -z ${CI_COMMIT_TAG} ]; then
        git -C repos/ clone -b ${CI_MERGE_REQUEST_SOURCE_BRANCH_NAME} ${CI_REPOSITORY_URL}
      else
        git -C repos/ clone -b ${CI_COMMIT_TAG} ${CI_REPOSITORY_URL}
      fi
    - |
      if [ -f tests/dependencies.yaml ]; then
        yq e ".*.git | path | .[-2]" "tests/dependencies.yaml" | while IFS= read -r i; do
          dep_branch=$(yq e ".${i}.git.tag" "tests/dependencies.yaml")
          if [[ -z ${dep_branch} || ${dep_branch} == "null" ]]; then
            dep_branch=$(yq e ".${i}.branch" "tests/dependencies.yaml")
          fi

          dep_repo=$(yq e ".${i}.git.repo" "tests/dependencies.yaml")
          if [[ -z ${dep_repo} || ${dep_repo} == "null" ]]; then
            dep_repo=$(yq e ".${i}.git" "tests/dependencies.yaml")
            if [[ -z ${dep_repo} || ${dep_repo} == "null" ]]; then
              continue
            fi
          fi

          if [[ -z ${dep_branch} || ${dep_branch} == "null" ]]; then
            git -C repos/ clone ${dep_repo}
          else
            git -C repos/ clone -b ${dep_branch} ${dep_repo}
          fi
        done
      fi
    - tar -czf $REPOS_PKG repos/
    # Prep release
    - mkdir -p release
    - mv $IMAGE_LIST $IMAGE_PKG $REPOS_PKG release/
    # Publish packages to s3 release
    - |
      if [ -z $CI_COMMIT_TAG ]; then
        aws configure set aws_region ${TEST_AWS_DEFAULT_REGION}
        aws configure set aws_access_key_id ${TEST_AWS_ACCESS_KEY_ID}
        aws configure set aws_secret_access_key ${TEST_AWS_SECRET_ACCESS_KEY}
        aws s3 cp --quiet release/${IMAGE_LIST} s3://${RELEASE_BUCKET}/tests/${CI_PROJECT_NAME}/${CI_COMMIT_SHA}/
        aws s3 cp --quiet release/${IMAGE_PKG} s3://${RELEASE_BUCKET}/tests/${CI_PROJECT_NAME}/${CI_COMMIT_SHA}/
        aws s3 cp --quiet release/${REPOS_PKG} s3://${RELEASE_BUCKET}/tests/${CI_PROJECT_NAME}/${CI_COMMIT_SHA}/
      else
        aws s3 sync --quiet release/ s3://${RELEASE_BUCKET}/packages/${CI_PROJECT_NAME}/${CI_COMMIT_TAG}
      fi
    # Get release notes from CHANGELOG
    - echo "# RELEASE NOTES:" >> release_notes.txt
    - |
      if [ -z $CI_COMMIT_TAG ]; then
        echo "Please see the repo [documentation](${CI_PROJECT_URL}/-/tree/${CI_COMMIT_SHA}/docs) for additional info on this package." >> release_notes.txt
      else
        echo "Please see the repo [documentation](${CI_PROJECT_URL}/-/tree/${CI_COMMIT_TAG}/docs) for additional info on this package." >> release_notes.txt
      fi
    - release_notes=$(cat CHANGELOG.md | sed  "1,/## \[${CI_COMMIT_TAG}]/d;/## \[/Q")
    - |
      if [[ -z $release_notes ]]; then
        printf "\n" >> release_notes.txt;
        echo "NO ENTRY IN CHANGELOG FOR THIS TAG, ADD RELEASE NOTES HERE" >> release_notes.txt;
      else
        printf "\n" >> release_notes.txt;
        echo "${release_notes}" >> release_notes.txt;
      fi
  artifacts:
    paths:
      - release_notes.txt
    expire_in: 3 days
  retry:
    max: 2
    when:
      - unknown_failure
      - stuck_or_timeout_failure
      - runner_system_failure

release:
  stage: release
  extends:
    - .bigbang-dogfood
  image: registry.gitlab.com/gitlab-org/release-cli:latest
  rules:
    # run job for manual tag events or test-ci::release MRs, check for AWS access
    - if: '($CI_COMMIT_TAG && $AWS_ACCESS_KEY_ID) || ($CI_MERGE_REQUEST_LABELS =~ /(^|,)test-ci::release(,|$)/ && $TEST_AWS_ACCESS_KEY_ID)'
  variables:
    RELEASE_ENDPOINT: https://${RELEASE_BUCKET}.s3-${AWS_DEFAULT_REGION}.amazonaws.com/packages/${CI_PROJECT_NAME}/${CI_COMMIT_TAG}
  script:
    # Use release-cli to cut a release in Gitlab or simulate a dry-run & print asset links
    - |
      if [ -z $CI_COMMIT_TAG ]; then
        RELEASE_ENDPOINT="https://${RELEASE_BUCKET}.s3-${TEST_AWS_DEFAULT_REGION}.amazonaws.com/tests/${CI_PROJECT_NAME}/${CI_COMMIT_SHA}"
        printf "Release will run: \n\
          release-cli create --name \"\${RELEASE_NAME} \${CI_COMMIT_SHA}\" --tag-name \${CI_COMMIT_SHA} \n\
            --description \"\$(cat release_notes.txt)\" \n\
            --assets-link \"{\"name\":\"${IMAGE_LIST}\",\"url\":\"${RELEASE_ENDPOINT}/${IMAGE_LIST}\"}\" \n\
            --assets-link \"{\"name\":\"${IMAGE_PKG}\",\"url\":\"${RELEASE_ENDPOINT}/${IMAGE_PKG}\"}\" \n\
            --assets-link \"{\"name\":\"${REPOS_PKG}\",\"url\":\"${RELEASE_ENDPOINT}/${REPOS_PKG}\"}\"\n"
      else
        release-cli create --name "${RELEASE_NAME} ${CI_COMMIT_TAG}" --tag-name ${CI_COMMIT_TAG} \
          --description "$(cat release_notes.txt)" \
          --assets-link "{\"name\":\"${IMAGE_LIST}\",\"url\":\"${RELEASE_ENDPOINT}/${IMAGE_LIST}\"}" \
          --assets-link "{\"name\":\"${IMAGE_PKG}\",\"url\":\"${RELEASE_ENDPOINT}/${IMAGE_PKG}\"}" \
          --assets-link "{\"name\":\"${REPOS_PKG}\",\"url\":\"${RELEASE_ENDPOINT}/${REPOS_PKG}\"}"
      fi
  retry:
    max: 2
    when:
      - unknown_failure
      - stuck_or_timeout_failure
      - runner_system_failure
