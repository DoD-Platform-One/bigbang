stages:
  - configuration validation
  - package tests

variables:
  PIPELINE_REPO: https://repo1.dso.mil/platform-one/big-bang/pipeline-templates/pipeline-templates.git
  PIPELINE_REPO_DESTINATION: "../pipeline-repo"
  PIPELINE_REPO_BRANCH: master

configuration validation:
  stage: configuration validation
  tags:
    - bigbang
    - public
    - privileged

  image:
    name: registry.dso.mil/platform-one/big-bang/pipeline-templates/pipeline-templates/k3d-builder:afdd9b77

  variables:
    GENERIC_POLICY_PATH: "${PIPELINE_REPO_DESTINATION}/policies"

  before_script:
    - git clone -b ${PIPELINE_REPO_BRANCH} ${PIPELINE_REPO} ${PIPELINE_REPO_DESTINATION}
  script:
    # Place configuration validation tests here
    - echo "Directory structure of repository:"
    - tree .
    - echo "Generic configuration validation tests:"

    # Global policy tests
    - helm conftest chart --policy ${GENERIC_POLICY_PATH}

    # Package specific tests
    - |
      if [ -d "tests/policy" ]; then
        echo "App specific configuration validation tests:"
        helm conftest chart --policy tests/policy
      fi

package tests:
  stage: package tests
  tags:
    - bigbang
    - public
    - privileged

  image:
    name: registry.dso.mil/platform-one/big-bang/pipeline-templates/pipeline-templates/k3d-builder:afdd9b77
  services:
    - registry.dso.mil/platform-one/big-bang/pipeline-templates/pipeline-templates/docker:dind
  variables:
    DOCKER_HOST: tcp://localhost:2375/
    DOCKER_DRIVER: overlay2
    DOCKER_TLS_CERTDIR: ""
    YAML_PARSE_PATH: "${PIPELINE_REPO_DESTINATION}/jobs/yml-parse/parse_yaml.sh"
    WAIT_PATH: "${PIPELINE_REPO_DESTINATION}/jobs/wait/wait.sh"

  artifacts:
    when: always
    paths:
      - tests/cypress/screenshots
      - tests/cypress/videos
    expire_in: 3 days

  before_script:
    # Starting dnsmasq for cluster dns resolution
    - docker run -d -p 53:53/udp -p 53:53 registry.dso.mil/platform-one/big-bang/pipeline-templates/pipeline-templates/go-dnsmasq:87fca1d1
    - echo "nameserver 127.0.0.1" >> /etc/resolv.conf

    # Create cluster and wait for deployments and pods
    - k3d cluster create ${CI_PROJECT_NAME} --servers 1 --k3s-server-arg "--disable=metrics-server" --k3s-server-arg "--disable=traefik" -p 80:80@loadbalancer -p 443:443@loadbalancer --wait
    - kubectl wait --for=condition=available --timeout 600s -A deployment --all > /dev/null
    - kubectl wait --for=condition=ready --timeout 600s -A pods --all --field-selector status.phase=Running > /dev/null

    # Setup pull secrets for project
    - |
      if [ ! -z ${PROJECT_NAME} ]; then
        CI_PROJECT_NAME=${PROJECT_NAME}
      fi
      kubectl create namespace ${CI_PROJECT_NAME}
      kubectl create -n ${CI_PROJECT_NAME} secret docker-registry private-registry --docker-server="https://registry1.dsop.io" --docker-username='robot$bigbang' --docker-password="${REGISTRY1_PASSWORD}"
      kubectl create -n ${CI_PROJECT_NAME} secret docker-registry private-registry-mil --docker-server="https://registry1.dso.mil" --docker-username='robot$bigbang' --docker-password="${REGISTRY1_PASSWORD}"

    # Clone pipeline repo for yaml parsing
    - git clone -b ${PIPELINE_REPO_BRANCH} ${PIPELINE_REPO} ${PIPELINE_REPO_DESTINATION}
    - source ${YAML_PARSE_PATH}
    - source ${WAIT_PATH}

    # Check for istio in project name and install it if needed
    - |
      if [[ "${CI_PROJECT_NAME}" != *"istio"* ]]; then
        istioctl install -y
      fi

    # Check for gateway if found generate throw away wildcard-cert secret and apply gateway
    - |
      if [ -f "tests/main-test-gateway.yaml" ]; then
        openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout tls.key -out tls.crt -subj "/CN=*.bigbang.dev"
        kubectl create -n istio-system secret tls wildcard-cert --key="tls.key" --cert="tls.crt"
        kubectl apply -f tests/main-test-gateway.yaml
      fi

    # Check for dependency repos, set up pull secrets, secret, and helm install with test-values if present default if not
    - |
      if [ -f "tests/dependencies.yaml" ]; then
        eval $(parse_yaml tests/dependencies.yaml "dependencies_")
        for git_repo in $(compgen -A variable | grep -w "dependencies_.*_git"); do

          dep_prefix=${git_repo%_*}
          dep_namespace_var=${dep_prefix}_namespace
          dep_namespace=$(printf '%s\n' "${!dep_namespace_var}")
          if [ -z ${dep_namespace} ]; then
            dep_namespace=$(echo "$dep_prefix" | sed -e "s/^dependencies_//")
          fi
          dep_branch_var=${dep_prefix}_branch
          dep_branch=$(printf '%s\n' "${!dep_branch_var}")
          dep_repo=$(printf '%s\n' "${!git_repo}")
          dep_repo_folder=$(echo "$dep_prefix" | sed -e "s/^dependencies_//")

          echo "Installing dependency: ${dep_repo_folder} into ${dep_namespace} namespace"
          if ! kubectl get namespace ${dep_namespace} 2> /dev/null; then
            kubectl create namespace ${dep_namespace};
          fi
          if ! kubectl get secret -n ${dep_namespace} private-registry 2> /dev/null; then
            kubectl create -n ${dep_namespace} secret docker-registry private-registry --docker-server="https://registry1.dsop.io" --docker-username='robot$bigbang' --docker-password="${REGISTRY1_PASSWORD}"
          fi
          if ! kubectl get secret -n ${dep_namespace} private-registry-mil 2> /dev/null; then
            kubectl create -n ${dep_namespace} secret docker-registry private-registry-mil --docker-server="https://registry1.dso.mil" --docker-username='robot$bigbang' --docker-password="${REGISTRY1_PASSWORD}"
          fi

          if [ ! -z ${dep_branch} ]; then
            echo "Cloning ${dep_branch} branch from ${dep_repo}"
            git clone -b ${dep_branch} ${dep_repo} ${dep_repo_folder}
          else
            echo "Cloning default branch from ${dep_repo}"
            git clone ${dep_repo} ${dep_repo_folder}
          fi

          if [ -f ${dep_repo_folder}/tests/test-values.yml ] ; then
            echo "Helm installing ${dep_repo_folder}/chart into ${dep_namespace} namespace using ${dep_repo_folder}/tests/test-values.yml for values"
            helm install --wait --timeout 600s ${dep_repo_folder} ${dep_repo_folder}/chart -n ${dep_namespace} -f ${dep_repo_folder}/tests/test-values.yml
          else
            echo "Helm installing ${dep_repo_folder}/chart into ${dep_namespace} namespace using default values"
            helm install --wait --timeout 600s ${dep_repo_folder} ${dep_repo_folder}/chart -n ${dep_namespace}
          fi
        done
      fi

    # Wait for resources to be created and come alive
    - sleep 10
    - kubectl wait --for=condition=established --timeout 60s -A crd --all > /dev/null
    - |
      if [ -f ${dep_repo_folder}/tests/wait.sh ]; then
        source ${dep_repo_folder}/tests/wait.sh
        echo "Waiting on dependency resources..."
        wait_project
      fi
    - wait_sts
    - kubectl wait --for=condition=available --timeout 600s -A deployment --all > /dev/null
    - kubectl wait --for=condition=ready --timeout 600s -A pods --all --field-selector status.phase=Running > /dev/null

    # If test-sysctl-mod exists apply it
    - |
      if [ -f "tests/test-sysctl-mod.yml" ]; then
        kubectl apply -f tests/test-sysctl-mod.yml
      fi

  script:
    # Place kubernetes package test here
    - echo "Package install"

    # Check for test values file
    - |
      if [ -f "tests/test-values.yml" ]  ; then
        echo "Helm installing ${CI_PROJECT_NAME}/chart into ${CI_PROJECT_NAME} namespace using ${CI_PROJECT_NAME}/tests/test-values.yml for values"
        helm install --wait --timeout 600s ${CI_PROJECT_NAME} chart -n ${CI_PROJECT_NAME} -f tests/test-values.yml
      else
        echo "Helm installing ${CI_PROJECT_NAME}/chart into ${CI_PROJECT_NAME} namespace using default values"
        helm install --wait --timeout 600s ${CI_PROJECT_NAME} chart -n ${CI_PROJECT_NAME}
      fi

    # Wait for resources to be created and come alive
    - sleep 10
    - kubectl wait --for=condition=established --timeout 60s -A crd --all > /dev/null
    - |
      if [ -f tests/wait.sh ]; then
        source tests/wait.sh
        echo "Waiting on project resources..."
        wait_project
      fi
    - wait_sts
    - kubectl wait --for=condition=available --timeout 600s -A deployment --all > /dev/null
    - kubectl wait --for=condition=ready --timeout 600s -A pods --all --field-selector status.phase=Running > /dev/null

    - echo "Package tests"
    - |
      if [ $CI_PROJECT_NAME == "istio-system" ]; then
        echo "certs required for gateway is created"
        openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout tls.key -out tls.crt -subj "/CN=*.bigbang.dev"
        kubectl create -n istio-system secret tls wildcard-cert --key="tls.key" --cert="tls.crt"
        sleep 10
      fi

    # If istio-ingressgateway has a loadBalancer IP and ${CI_PROJECT_NAME} namespace has a virtualService hostname add value to /etc/hosts
    - |
      if [ ! -z $(kubectl get services -n istio-system istio-ingressgateway -o jsonpath='{.status.loadBalancer.ingress[0].ip}') ] && [ ! -z $(kubectl get vs -A -o jsonpath='{.items[0].spec.hosts[0]}') ]; then
        echo "$(kubectl get services -n istio-system istio-ingressgateway -o jsonpath='{.status.loadBalancer.ingress[0].ip}') $(kubectl get vs -A -o jsonpath='{.items[*].spec.hosts[0]}')" >> /etc/hosts
      fi

    # Run Cypress tests
    - |
      if [ -f "tests/cypress.json" ]; then
        cd tests && cypress run
      fi
      
    # File to indicate Job succeeded 
    - touch $CI_PROJECT_DIR/success

  after_script:
    - |
        if [ -e success ]; then
          echo "Job Succeeded"
        else
          echo "Job Failed Printing Debug Logs"
          echo "kubectl get all -A"
          kubectl get all -A
        fi

    # Delete Cluster
    - k3d cluster delete ${CI_PROJECT_NAME}
